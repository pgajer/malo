## ============================================================================
## R Wrappers for External Bayesian Bootstrap Functions
## ============================================================================
##
## These functions enable paired BB comparisons by using pre-generated
## Dirichlet weights. This is essential for proper paired hypothesis testing.
##
## @author Pawel Gajer
## @date 2025
## ============================================================================


#' Generate Dirichlet(1,...,1) Weights for Bayesian Bootstrap
#'
#' Generates a matrix of Dirichlet weights that can be used for paired
#' Bayesian bootstrap comparisons. Each column contains weights that sum to n
#' (not normalized to 1, as BB convention uses n * w).
#'
#' @param n     Integer. Number of data points (length of weight vectors).
#' @param n.BB  Integer. Number of BB iterations (columns).
#' @param seed  Integer or NULL. Random seed for reproducibility.
#'
#' @return A numeric matrix of dimension n x n.BB, where each column contains
#'   Dirichlet(1,...,1) weights scaled to sum to n.
#'
#' @details
#' The Dirichlet(1,...,1) distribution is uniform on the (n-1)-dimensional
#' simplex. Weights are generated by:
#' 1. Draw n independent Exponential(1) random variables
#' 2. Normalize to sum to n
#'
#' The resulting weights have mean 1 for each element, which is the expected
#' value under uniform sampling.
#'
#' @examples
#' \dontrun{
#' # Generate 100 weight vectors for 50 data points
#' lambda <- generate.dirichlet.weights(50, 100, seed = 123)
#'
#' # Verify columns sum to n
#' colSums(lambda)  # Should all be 50
#' }
#'
#' @export
generate.dirichlet.weights <- function(n, n.BB, seed = NULL) {

    stopifnot(is.numeric(n) && length(n) == 1 && n >= 2)
    stopifnot(is.numeric(n.BB) && length(n.BB) == 1 && n.BB >= 1)

    n <- as.integer(n)
    n.BB <- as.integer(n.BB)

    if (!is.null(seed)) {
        set.seed(seed)
    }

    ## Call C function
    lambda <- .malo.Call("S_generate_dirichlet_weights",
                    n, n.BB,
                    PACKAGE = "malo")

    return(lambda)
}


#' Bayesian Bootstrap gpredictions with External Weights
#'
#' Generates BB gpredictions (predictions on grid) using externally provided
#' Dirichlet weights. This enables paired comparisons where signal and null
#' computations use the same weights.
#'
#' @param n.BB         Integer. Number of BB iterations.
#' @param nn.i         Matrix of neighbor indices (ng x K).
#' @param nn.x         Matrix of x values over neighbors (ng x K).
#' @param nn.y         Matrix of y values over neighbors (ng x K).
#' @param y.binary     Logical. If TRUE, restrict predictions to \eqn{[0,1]}.
#' @param nn.w         Matrix of base weights (ng x K).
#' @param nx           Integer. Number of original data points.
#' @param max.K        Integer vector. Maximum neighbor indices per grid point.
#' @param degree       Integer. Polynomial degree (1 or 2).
#' @param grid.nn.i    Matrix of grid neighbor indices.
#' @param grid.nn.x    Matrix of grid neighbor x values.
#' @param grid.nn.w    Matrix of grid neighbor weights.
#' @param grid.max.K   Integer vector. Max neighbor indices for grid.
#' @param lambda       Matrix of external weights (nx x n.BB).
#'
#' @return A list with components:
#'   \describe{
#'     \item{bb.gpredictions}{Matrix of BB gpredictions (ng x n.BB)}
#'     \item{bb.dgpredictions}{Matrix of BB derivative estimates (ng x n.BB)}
#'   }
#'
#' @details
#' This function is identical to \code{get.BB.gpredictions} except that it
#' accepts pre-generated Dirichlet weights instead of generating them internally.
#' The lambda matrix should be generated using \code{generate.dirichlet.weights}.
#'
#' @seealso \code{\link{generate.dirichlet.weights}}
#'
#' @keywords internal
get.BB.gpredictions.external <- function(n.BB,
                                         nn.i,
                                         nn.x,
                                         nn.y,
                                         y.binary,
                                         nn.w,
                                         nx,
                                         max.K,
                                         degree,
                                         grid.nn.i,
                                         grid.nn.x,
                                         grid.nn.w,
                                         grid.max.K,
                                         lambda) {

    ## Input validation
    stopifnot(is.matrix(lambda))
    stopifnot(nrow(lambda) == nx)
    stopifnot(ncol(lambda) == n.BB)

    ng <- nrow(nn.i)
    K <- ncol(nn.i)

    grid.ng <- nrow(grid.nn.i)
    grid.K <- ncol(grid.nn.i)

    ## Call C function via .Call
    result <- .malo.Call("S_get_BB_Eyg_external",
                    as.integer(n.BB),
                    as.integer(t(nn.i - 1)),      # 0-based, transposed
                    as.double(t(nn.x)),
                    as.double(t(nn.y)),
                    as.integer(y.binary),
                    as.double(t(nn.w)),
                    as.integer(nx),
                    as.integer(K),                # nrTnn after transpose
                    as.integer(ng),               # ncTnn after transpose
                    as.integer(max.K - 1),        # 0-based
                    as.integer(degree),
                    as.integer(t(grid.nn.i - 1)), # 0-based, transposed
                    as.double(t(grid.nn.x)),
                    as.double(t(grid.nn.w)),
                    as.integer(grid.K),           # nrTgrid_nn
                    as.integer(grid.ng),          # ncTgrid_nn
                    as.integer(grid.max.K - 1),   # 0-based
                    as.double(lambda),
                    PACKAGE = "malo")

    return(result)
}


#' Legacy-Compatible External BB Smoother Wrapper
#'
#' A legacy-compatible wrapper that accepts the historical
#' \code{magelo.with.external.BB()} interface while using a spline-based
#' backend. This keeps paired BB workflows working without depending on
#' the legacy \code{magelo()} fitting path.
#'
#' @param x           Numeric vector of predictor values.
#' @param y           Numeric vector of response values.
#' @param lambda      Matrix of external BB weights (length(x) x n.BB).
#' @param bw          Optional spline smoothing control. If \code{NULL}, default
#'   spline settings are used.
#' @param grid.size   Number of grid points. Default is 400.
#' @param degree      Legacy polynomial degree metadata (0, 1, or 2). Retained
#'   for compatibility.
#' @param min.K       Legacy minimum-neighbor metadata retained for compatibility.
#' @param nn.kernel   Legacy kernel argument retained for compatibility.
#'
#' @return A list with components:
#'   \describe{
#'     \item{gpredictions}{Point estimate on grid}
#'     \item{BB.gpredictions}{Matrix of BB gpredictions (ng x n.BB)}
#'     \item{BB.dgpredictions}{Matrix of finite-difference BB derivatives
#'       (ng x n.BB)}
#'     \item{xgrid}{Grid points}
#'     \item{opt.bw}{Smoothing control used by the backend}
#'   }
#'
#' @details
#' This function generates BB samples using provided external weights and a
#' spline smoother. For paired comparisons, call this function twice
#' (for signal and null) with the same \code{lambda} matrix.
#'
#' @examples
#' \dontrun{
#' # Generate data
#' x <- runif(100)
#' y <- sin(2*pi*x) + rnorm(100, sd = 0.2)
#'
#' # Generate shared weights
#' lambda <- generate.dirichlet.weights(100, 500)
#'
#' # Fit signal model
#' signal <- magelo.with.external.BB(x, y, lambda)
#'
#' # Fit null model (permuted y)
#' null <- magelo.with.external.BB(x, sample(y), lambda)
#'
#' # Now signal and null BB samples use the same weights
#' }
#'
#' @export
magelo.with.external.BB <- function(x,
                                    y,
                                    lambda,
                                    bw = NULL,
                                    grid.size = 400,
                                    degree = 1,
                                    min.K = 5,
                                    nn.kernel = "epanechnikov") {
    .gflow.warn.legacy.1d.api(
        api = "magelo.with.external.BB()",
        replacement = "Use the spline-backed functional association workflows in gflow for new analyses."
    )

    if (!is.numeric(x) || !is.numeric(y)) {
        stop("'x' and 'y' must be numeric")
    }
    if (length(x) != length(y)) {
        stop("'x' and 'y' must have the same length")
    }
    if (!is.matrix(lambda)) {
        lambda <- as.matrix(lambda)
    }
    if (nrow(lambda) != length(x)) {
        stop("'lambda' must have nrow(lambda) == length(x)")
    }
    if (!is.numeric(grid.size) || length(grid.size) != 1L || !is.finite(grid.size) || grid.size < 10) {
        stop("'grid.size' must be a finite numeric scalar >= 10")
    }
    if (!is.numeric(degree) || length(degree) != 1L || !is.finite(degree) || !(as.integer(degree) %in% c(0L, 1L, 2L))) {
        stop("'degree' must be one of 0, 1, or 2")
    }
    if (!is.numeric(min.K) || length(min.K) != 1L || !is.finite(min.K) || min.K < 2) {
        stop("'min.K' must be a finite numeric scalar >= 2")
    }
    if (!is.null(bw) && (!is.numeric(bw) || length(bw) != 1L || !is.finite(bw) || bw <= 0)) {
        stop("'bw' must be NULL or a positive finite numeric scalar")
    }

    kernels <- c("epanechnikov", "triangular", "tr.exponential", "normal")
    nn.kernel <- match.arg(nn.kernel, kernels)
    if (!identical(nn.kernel, "epanechnikov")) {
        warning("'nn.kernel' is ignored by the spline backend and kept only for compatibility.",
                call. = FALSE)
    }
    if (as.integer(degree) != 1L) {
        warning("'degree' is retained for compatibility and does not alter spline fitting.",
                call. = FALSE)
    }
    if (as.integer(min.K) != 5L) {
        warning("'min.K' is retained for compatibility and does not alter spline fitting.",
                call. = FALSE)
    }

    if (any(!is.finite(x)) || any(!is.finite(y))) {
        stop("'x' and 'y' must be finite")
    }
    if (any(!is.finite(lambda)) || any(lambda < 0)) {
        stop("'lambda' must contain finite non-negative values")
    }

    o <- order(x)
    x <- as.numeric(x[o])
    y <- as.numeric(y[o])
    lambda <- lambda[o, , drop = FALSE]
    storage.mode(lambda) <- "double"

    spline.fit <- .gflow.with.external.BB.spline(
        x = x,
        y = y,
        lambda = lambda,
        bw = bw,
        grid.size = as.integer(grid.size),
        degree = as.integer(degree),
        min.K = as.integer(min.K)
    )

    gpredictions <- spline.fit$gpredictions
    BB.gpredictions <- spline.fit$BB.gpredictions

    if (all(y %in% c(0, 1))) {
        gpredictions <- pmin(pmax(gpredictions, 0), 1)
        BB.gpredictions <- pmin(pmax(BB.gpredictions, 0), 1)
    }

    xgrid <- as.numeric(spline.fit$xgrid)
    n.BB <- ncol(lambda)

    BB.dgpredictions <- matrix(0, nrow = nrow(BB.gpredictions), ncol = ncol(BB.gpredictions))
    if (length(xgrid) > 1L && nrow(BB.gpredictions) > 1L) {
        dx <- diff(xgrid)
        dx[!is.finite(dx) | dx == 0] <- 1
        for (b in seq_len(n.BB)) {
            d <- diff(BB.gpredictions[, b]) / dx
            BB.dgpredictions[1, b] <- d[1]
            BB.dgpredictions[nrow(BB.dgpredictions), b] <- d[length(d)]
            if (nrow(BB.dgpredictions) > 2L) {
                BB.dgpredictions[2:(nrow(BB.dgpredictions) - 1L), b] <- (d[-1] + d[-length(d)]) / 2
            }
        }
    }

    list(
        gpredictions = gpredictions,
        BB.gpredictions = BB.gpredictions,
        BB.dgpredictions = BB.dgpredictions,
        xgrid = xgrid,
        opt.bw = spline.fit$opt.bw,
        x = x,
        y = y,
        degree = as.integer(degree),
        n.BB = n.BB,
        lambda = lambda,
        fit.method = "spline_compat"
    )
}
